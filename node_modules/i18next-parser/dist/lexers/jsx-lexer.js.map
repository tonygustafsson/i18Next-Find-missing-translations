{"version":3,"file":"jsx-lexer.js","names":["JavascriptLexer","ts","unescape","JsxLexer","options","transSupportBasicHtmlNodes","transKeepBasicHtmlNodesFor","omitAttributes","attr","content","filename","keys","parseCommentNode","createCommentNodeParser","parseTree","node","entry","kind","SyntaxKind","CallExpression","expressionExtractor","call","TaggedTemplateExpression","taggedTemplateExpressionExtractor","JsxElement","jsxExtractor","JsxSelfClosingElement","push","forEachChild","sourceFile","createSourceFile","ScriptTarget","Latest","keysWithNamespace","setNamespaces","keysWithPrefixes","setKeyPrefixes","sourceText","tagNode","openingElement","getPropValue","attributeName","attribute","attributes","properties","find","name","undefined","text","initializer","expression","Identifier","emit","getKey","tagName","key","namespace","forEach","property","JsxSpreadAttribute","includes","TrueKeyword","FalseKeyword","defaultsProp","defaultValue","nodeToString","shouldUnescape","children","parseChildren","elemsToString","map","child","index","type","useTagName","isBasic","elementName","childrenString","selfClosing","Error","join","JsxText","replace","element","escapedText","length","JsxExpression","AsExpression","StringLiteral","ObjectLiteralExpression","nonFormatProperties","filter","prop","slice","pos","end"],"sources":["../../src/lexers/jsx-lexer.js"],"sourcesContent":["import JavascriptLexer from './javascript-lexer.js'\nimport ts from 'typescript'\nimport { unescape } from '../helpers.js'\n\nexport default class JsxLexer extends JavascriptLexer {\n  constructor(options = {}) {\n    super(options)\n\n    this.transSupportBasicHtmlNodes =\n      options.transSupportBasicHtmlNodes || false\n    this.transKeepBasicHtmlNodesFor = options.transKeepBasicHtmlNodesFor || [\n      'br',\n      'strong',\n      'i',\n      'p',\n    ]\n    this.omitAttributes = [this.attr, 'ns', 'defaults']\n  }\n\n  extract(content, filename = '__default.jsx') {\n    const keys = []\n\n    const parseCommentNode = this.createCommentNodeParser()\n\n    const parseTree = (node) => {\n      let entry\n\n      parseCommentNode(keys, node, content)\n\n      switch (node.kind) {\n        case ts.SyntaxKind.CallExpression:\n          entry = this.expressionExtractor.call(this, node)\n          break\n        case ts.SyntaxKind.TaggedTemplateExpression:\n          entry = this.taggedTemplateExpressionExtractor.call(this, node)\n          break\n        case ts.SyntaxKind.JsxElement:\n          entry = this.jsxExtractor.call(this, node, content)\n          break\n        case ts.SyntaxKind.JsxSelfClosingElement:\n          entry = this.jsxExtractor.call(this, node, content)\n          break\n      }\n\n      if (entry) {\n        keys.push(entry)\n      }\n\n      node.forEachChild(parseTree)\n    }\n\n    const sourceFile = ts.createSourceFile(\n      filename,\n      content,\n      ts.ScriptTarget.Latest\n    )\n    parseTree(sourceFile)\n\n    const keysWithNamespace = this.setNamespaces(keys)\n    const keysWithPrefixes = this.setKeyPrefixes(keysWithNamespace)\n\n    return keysWithPrefixes\n  }\n\n  jsxExtractor(node, sourceText) {\n    const tagNode = node.openingElement || node\n\n    const getPropValue = (node, attributeName) => {\n      const attribute = node.attributes.properties.find(\n        (attr) => attr.name !== undefined && attr.name.text === attributeName\n      )\n      if (!attribute) {\n        return undefined\n      }\n\n      if (attribute.initializer.expression?.kind === ts.SyntaxKind.Identifier) {\n        this.emit(\n          'warning',\n          `Namespace is not a string literal: ${attribute.initializer.expression.text}`\n        )\n        return undefined\n      }\n\n      return attribute.initializer.expression\n        ? attribute.initializer.expression.text\n        : attribute.initializer.text\n    }\n\n    const getKey = (node) => getPropValue(node, this.attr)\n\n    if (tagNode.tagName.text === 'Trans') {\n      const entry = {}\n      entry.key = getKey(tagNode)\n\n      const namespace = getPropValue(tagNode, 'ns')\n      if (namespace) {\n        entry.namespace = namespace\n      }\n\n      tagNode.attributes.properties.forEach((property) => {\n        if (property.kind === ts.SyntaxKind.JsxSpreadAttribute) {\n          this.emit(\n            'warning',\n            `Component attribute is a JSX spread attribute : ${property.expression.text}`\n          )\n          return\n        }\n\n        if (this.omitAttributes.includes(property.name.text)) {\n          return\n        }\n\n        if (property.initializer) {\n          if (property.initializer.expression) {\n            if (\n              property.initializer.expression.kind === ts.SyntaxKind.TrueKeyword\n            ) {\n              entry[property.name.text] = true\n            } else if (\n              property.initializer.expression.kind ===\n              ts.SyntaxKind.FalseKeyword\n            ) {\n              entry[property.name.text] = false\n            } else {\n              entry[\n                property.name.text\n              ] = `{${property.initializer.expression.text}}`\n            }\n          } else {\n            entry[property.name.text] = property.initializer.text\n          }\n        } else entry[property.name.text] = true\n      })\n\n      const defaultsProp = getPropValue(tagNode, 'defaults')\n      let defaultValue =\n        defaultsProp || this.nodeToString.call(this, node, sourceText)\n\n      if (entry.shouldUnescape === true) {\n        defaultValue = unescape(defaultValue)\n      }\n\n      if (defaultValue !== '') {\n        entry.defaultValue = defaultValue\n\n        if (!entry.key) {\n          entry.key = entry.defaultValue\n        }\n      }\n\n      return entry.key ? entry : null\n    } else if (tagNode.tagName.text === 'Interpolate') {\n      const entry = {}\n      entry.key = getKey(tagNode)\n      return entry.key ? entry : null\n    }\n  }\n\n  nodeToString(node, sourceText) {\n    const children = this.parseChildren.call(this, node.children, sourceText)\n\n    const elemsToString = (children) =>\n      children\n        .map((child, index) => {\n          switch (child.type) {\n            case 'js':\n            case 'text':\n              return child.content\n            case 'tag':\n              const useTagName =\n                child.isBasic &&\n                this.transSupportBasicHtmlNodes &&\n                this.transKeepBasicHtmlNodesFor.includes(child.name)\n              const elementName = useTagName ? child.name : index\n              const childrenString = elemsToString(child.children)\n              return childrenString || !(useTagName && child.selfClosing)\n                ? `<${elementName}>${childrenString}</${elementName}>`\n                : `<${elementName} />`\n            default:\n              throw new Error('Unknown parsed content: ' + child.type)\n          }\n        })\n        .join('')\n\n    return elemsToString(children)\n  }\n\n  parseChildren(children = [], sourceText) {\n    return children\n      .map((child) => {\n        if (child.kind === ts.SyntaxKind.JsxText) {\n          return {\n            type: 'text',\n            content: child.text\n              .replace(/(^(\\n|\\r)\\s*)|((\\n|\\r)\\s*$)/g, '')\n              .replace(/(\\n|\\r)\\s*/g, ' '),\n          }\n        } else if (\n          child.kind === ts.SyntaxKind.JsxElement ||\n          child.kind === ts.SyntaxKind.JsxSelfClosingElement\n        ) {\n          const element = child.openingElement || child\n          const name = element.tagName.escapedText\n          const isBasic = !element.attributes.properties.length\n          return {\n            type: 'tag',\n            children: this.parseChildren(child.children, sourceText),\n            name,\n            isBasic,\n            selfClosing: child.kind === ts.SyntaxKind.JsxSelfClosingElement,\n          }\n        } else if (child.kind === ts.SyntaxKind.JsxExpression) {\n          // strip empty expressions\n          if (!child.expression) {\n            return {\n              type: 'text',\n              content: '',\n            }\n          }\n\n          // simplify trivial expressions, like TypeScript typecasts\n          if (child.expression.kind === ts.SyntaxKind.AsExpression) {\n            child = child.expression\n          }\n\n          if (child.expression.kind === ts.SyntaxKind.StringLiteral) {\n            return {\n              type: 'text',\n              content: child.expression.text,\n            }\n          }\n\n          // strip properties from ObjectExpressions\n          // annoying (and who knows how many other exceptions we'll need to write) but necessary\n          else if (\n            child.expression.kind === ts.SyntaxKind.ObjectLiteralExpression\n          ) {\n            // i18next-react only accepts two props, any random single prop, and a format prop\n            // for our purposes, format prop is always ignored\n\n            let nonFormatProperties = child.expression.properties.filter(\n              (prop) => prop.name.text !== 'format'\n            )\n\n            // more than one property throw a warning in i18next-react, but still works as a key\n            if (nonFormatProperties.length > 1) {\n              this.emit(\n                'warning',\n                `The passed in object contained more than one variable - the object should look like {{ value, format }} where format is optional.`\n              )\n\n              return {\n                type: 'text',\n                content: '',\n              }\n            }\n\n            return {\n              type: 'js',\n              content: `{{${nonFormatProperties[0].name.text}}}`,\n            }\n          }\n\n          // slice on the expression so that we ignore comments around it\n          return {\n            type: 'js',\n            content: `{${sourceText.slice(\n              child.expression.pos,\n              child.expression.end\n            )}}`,\n          }\n        } else {\n          throw new Error('Unknown ast element when parsing jsx: ' + child.kind)\n        }\n      })\n      .filter((child) => child.type !== 'text' || child.content)\n  }\n}\n"],"mappings":"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"}