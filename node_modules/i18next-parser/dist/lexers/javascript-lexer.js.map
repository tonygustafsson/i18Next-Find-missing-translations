{"version":3,"file":"javascript-lexer.js","names":["BaseLexer","ts","JavascriptLexer","options","callPattern","functionPattern","functions","namespaceFunctions","attr","parseGenerics","typeMap","visitedComments","Set","keys","node","content","forEachLeadingCommentRange","getFullStart","pos","end","kind","commentId","SyntaxKind","MultiLineCommentTrivia","SingleLineCommentTrivia","has","add","text","slice","commentKeys","commentExtractor","call","push","defaultNamespace","map","entry","namespace","keyPrefix","key","filename","parseCommentNode","createCommentNodeParser","parseTree","TaggedTemplateExpression","taggedTemplateExpressionExtractor","CallExpression","expressionExtractor","forEachChild","sourceFile","createSourceFile","ScriptTarget","Latest","setNamespaces","tag","template","isTranslationFunction","includes","name","NoSubstitutionTemplateLiteral","TemplateExpression","emit","expression","escapedText","arguments","length","elements","optionsArgument","ObjectLiteralExpression","properties","find","p","keyPrefixValue","initializer","keyArgument","shift","StringLiteral","BinaryExpression","concatenatedString","concatenateString","Identifier","typeArguments","typeArgument","parseTypeArgument","typeArg","TypeLiteral","members","member","TypeReference","typeName","Object","assign","Array","isArray","types","forEach","tp","defaultValue","SpreadAssignment","TrueKeyword","FalseKeyword","ns","commentText","regexp","RegExp","expressions","match","expressionKeys","extract","binaryExpression","string","operatorToken","PlusToken","left","right"],"sources":["../../src/lexers/javascript-lexer.js"],"sourcesContent":["import BaseLexer from './base-lexer.js'\nimport ts from 'typescript'\n\nexport default class JavascriptLexer extends BaseLexer {\n  constructor(options = {}) {\n    super(options)\n\n    this.callPattern = '(?<=^|\\\\s|\\\\.)' + this.functionPattern() + '\\\\(.*\\\\)'\n    this.functions = options.functions || ['t']\n    this.namespaceFunctions = options.namespaceFunctions || [\n      'useTranslation',\n      'withTranslation',\n    ]\n    this.attr = options.attr || 'i18nKey'\n    this.parseGenerics = options.parseGenerics || false\n    this.typeMap = options.typeMap || {}\n  }\n\n  createCommentNodeParser() {\n    const visitedComments = new Set()\n\n    return (keys, node, content) => {\n      ts.forEachLeadingCommentRange(\n        content,\n        node.getFullStart(),\n        (pos, end, kind) => {\n          const commentId = `${pos}_${end}`\n          if (\n            (kind === ts.SyntaxKind.MultiLineCommentTrivia ||\n              kind === ts.SyntaxKind.SingleLineCommentTrivia) &&\n            !visitedComments.has(commentId)\n          ) {\n            visitedComments.add(commentId)\n            const text = content.slice(pos, end)\n            const commentKeys = this.commentExtractor.call(this, text)\n            if (commentKeys) {\n              keys.push(...commentKeys)\n            }\n          }\n        }\n      )\n    }\n  }\n\n  setNamespaces(keys) {\n    if (this.defaultNamespace) {\n      return keys.map((entry) => ({\n        ...entry,\n        namespace: entry.namespace || this.defaultNamespace,\n      }))\n    }\n\n    return keys\n  }\n\n  setKeyPrefixes(keys) {\n    if (this.keyPrefix) {\n      return keys.map((key) => ({\n        ...key,\n        keyPrefix: this.keyPrefix,\n      }))\n    }\n\n    return keys\n  }\n\n  extract(content, filename = '__default.js') {\n    const keys = []\n\n    const parseCommentNode = this.createCommentNodeParser()\n\n    const parseTree = (node) => {\n      let entry\n\n      parseCommentNode(keys, node, content)\n\n      if (node.kind === ts.SyntaxKind.TaggedTemplateExpression) {\n        entry = this.taggedTemplateExpressionExtractor.call(this, node)\n      }\n\n      if (node.kind === ts.SyntaxKind.CallExpression) {\n        entry = this.expressionExtractor.call(this, node)\n      }\n\n      if (entry) {\n        keys.push(entry)\n      }\n\n      node.forEachChild(parseTree)\n    }\n\n    const sourceFile = ts.createSourceFile(\n      filename,\n      content,\n      ts.ScriptTarget.Latest\n    )\n    parseTree(sourceFile)\n\n    return this.setNamespaces(keys)\n  }\n\n  taggedTemplateExpressionExtractor(node) {\n    const entry = {}\n\n    const { tag, template } = node\n\n    const isTranslationFunction =\n      (tag.text && this.functions.includes(tag.text)) ||\n      (tag.name && this.functions.includes(tag.name.text))\n\n    if (!isTranslationFunction) return null\n\n    if (template.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral) {\n      entry.key = template.text\n    } else if (template.kind === ts.SyntaxKind.TemplateExpression) {\n      this.emit(\n        'warning',\n        'A key that is a template string must not have any interpolations.'\n      )\n      return null\n    }\n\n    return entry\n  }\n\n  expressionExtractor(node) {\n    const entry = {}\n\n    if (\n      this.namespaceFunctions.includes(node.expression.escapedText) &&\n      node.arguments.length\n    ) {\n      const { text, elements } = node.arguments[0]\n\n      // useTranslation\n      if (text) {\n        this.defaultNamespace = text\n        const optionsArgument = node.arguments[1]\n\n        if (\n          optionsArgument &&\n          optionsArgument.kind === ts.SyntaxKind.ObjectLiteralExpression\n        ) {\n          const node = optionsArgument.properties.find(\n            (p) => p.name.escapedText === 'keyPrefix'\n          )\n          if (node != null) {\n            const keyPrefixValue = node.initializer.text\n            this.keyPrefix = keyPrefixValue\n          }\n        }\n        // withTranslation\n      } else if (elements && elements.length) {\n        this.defaultNamespace = elements[0].text\n      }\n    }\n\n    const isTranslationFunction =\n      (node.expression.text && this.functions.includes(node.expression.text)) ||\n      (node.expression.name &&\n        this.functions.includes(node.expression.name.text))\n\n    if (isTranslationFunction) {\n      const keyArgument = node.arguments.shift()\n\n      if (!keyArgument) {\n        return null\n      }\n\n      if (\n        keyArgument.kind === ts.SyntaxKind.StringLiteral ||\n        keyArgument.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral\n      ) {\n        entry.key = keyArgument.text\n      } else if (keyArgument.kind === ts.SyntaxKind.BinaryExpression) {\n        const concatenatedString = this.concatenateString(keyArgument)\n        if (!concatenatedString) {\n          this.emit(\n            'warning',\n            `Key is not a string literal: ${keyArgument.text}`\n          )\n          return null\n        }\n        entry.key = concatenatedString\n      } else {\n        this.emit(\n          'warning',\n          keyArgument.kind === ts.SyntaxKind.Identifier\n            ? `Key is not a string literal: ${keyArgument.text}`\n            : 'Key is not a string literal'\n        )\n        return null\n      }\n\n      if (this.parseGenerics && node.typeArguments) {\n        let typeArgument = node.typeArguments.shift()\n\n        const parseTypeArgument = (typeArg) => {\n          if (!typeArg) {\n            return\n          }\n          if (typeArg.kind === ts.SyntaxKind.TypeLiteral) {\n            for (const member of typeArg.members) {\n              entry[member.name.text] = ''\n            }\n          } else if (\n            typeArg.kind === ts.SyntaxKind.TypeReference &&\n            typeArg.typeName.kind === ts.SyntaxKind.Identifier\n          ) {\n            const typeName = typeArg.typeName.text\n            if (typeName in this.typeMap) {\n              Object.assign(entry, this.typeMap[typeName])\n            }\n          } else if (Array.isArray(typeArg.types)) {\n            typeArgument.types.forEach((tp) => parseTypeArgument(tp))\n          }\n        }\n\n        parseTypeArgument(typeArgument)\n      }\n\n      let optionsArgument = node.arguments.shift()\n\n      // Second argument could be a string default value\n      if (\n        optionsArgument &&\n        (optionsArgument.kind === ts.SyntaxKind.StringLiteral ||\n          optionsArgument.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral)\n      ) {\n        entry.defaultValue = optionsArgument.text\n        optionsArgument = node.arguments.shift()\n      }\n\n      if (\n        optionsArgument &&\n        optionsArgument.kind === ts.SyntaxKind.ObjectLiteralExpression\n      ) {\n        for (const p of optionsArgument.properties) {\n          if (p.kind === ts.SyntaxKind.SpreadAssignment) {\n            this.emit(\n              'warning',\n              `Options argument is a spread operator : ${p.expression.text}`\n            )\n          } else if (p.initializer) {\n            if (p.initializer.kind === ts.SyntaxKind.TrueKeyword) {\n              entry[p.name.text] = true\n            } else if (p.initializer.kind === ts.SyntaxKind.FalseKeyword) {\n              entry[p.name.text] = false\n            } else {\n              entry[p.name.text] = p.initializer.text || ''\n            }\n          } else {\n            entry[p.name.text] = ''\n          }\n        }\n      }\n\n      if (entry.ns) {\n        if (typeof entry.ns === 'string') {\n          entry.namespace = entry.ns\n        } else if (typeof entry.ns === 'object' && entry.ns.length) {\n          entry.namespace = entry.ns[0]\n        }\n      }\n\n      return entry\n    }\n\n    return null\n  }\n\n  commentExtractor(commentText) {\n    const regexp = new RegExp(this.callPattern, 'g')\n    const expressions = commentText.match(regexp)\n\n    if (!expressions) {\n      return null\n    }\n\n    const keys = []\n    expressions.forEach((expression) => {\n      const expressionKeys = this.extract(expression)\n      if (expressionKeys) {\n        keys.push(...expressionKeys)\n      }\n    })\n    return keys\n  }\n\n  concatenateString(binaryExpression, string = '') {\n    if (binaryExpression.operatorToken.kind !== ts.SyntaxKind.PlusToken) {\n      return\n    }\n\n    if (binaryExpression.left.kind === ts.SyntaxKind.BinaryExpression) {\n      string += this.concatenateString(binaryExpression.left, string)\n    } else if (binaryExpression.left.kind === ts.SyntaxKind.StringLiteral) {\n      string += binaryExpression.left.text\n    } else {\n      return\n    }\n\n    if (binaryExpression.right.kind === ts.SyntaxKind.BinaryExpression) {\n      string += this.concatenateString(binaryExpression.right, string)\n    } else if (binaryExpression.right.kind === ts.SyntaxKind.StringLiteral) {\n      string += binaryExpression.right.text\n    } else {\n      return\n    }\n\n    return string\n  }\n}\n"],"mappings":"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"}