{"version":3,"file":"handlebars-lexer.js","names":["BaseLexer","HandlebarsLexer","options","functions","createFunctionRegex","createArgumentsRegex","content","matches","functionRegex","exec","args","parseArguments","populateKeysFromArguments","keys","result","arguments","argumentsRegex","arg","parts","split","push","length","validateString","value","slice","firstArgument","secondArgument","isKeyString","isDefaultValueString","emit","key","defaultValue","functionPattern","curlyPattern","parenthesisPattern","pattern","RegExp","variablePattern","stringOrVariablePattern","stringPattern"],"sources":["../../src/lexers/handlebars-lexer.js"],"sourcesContent":["import BaseLexer from './base-lexer.js'\n\nexport default class HandlebarsLexer extends BaseLexer {\n  constructor(options = {}) {\n    super(options)\n\n    this.functions = options.functions || ['t']\n\n    this.createFunctionRegex()\n    this.createArgumentsRegex()\n  }\n\n  extract(content) {\n    let matches\n\n    while ((matches = this.functionRegex.exec(content))) {\n      const args = this.parseArguments(matches[1] || matches[2])\n      this.populateKeysFromArguments(args)\n    }\n\n    return this.keys\n  }\n\n  parseArguments(args) {\n    let matches\n    const result = {\n      arguments: [],\n      options: {},\n    }\n    while ((matches = this.argumentsRegex.exec(args))) {\n      const arg = matches[1]\n      const parts = arg.split('=')\n      result.arguments.push(arg)\n      if (parts.length === 2 && this.validateString(parts[1])) {\n        const value = parts[1].slice(1, -1)\n        if (value === 'true') {\n          result.options[parts[0]] = true\n        } else if (value === 'false') {\n          result.options[parts[0]] = false\n        } else {\n          result.options[parts[0]] = value\n        }\n      }\n    }\n    return result\n  }\n\n  populateKeysFromArguments(args) {\n    const firstArgument = args.arguments[0]\n    const secondArgument = args.arguments[1]\n    const isKeyString = this.validateString(firstArgument)\n    const isDefaultValueString = this.validateString(secondArgument)\n\n    if (!isKeyString) {\n      this.emit('warning', `Key is not a string literal: ${firstArgument}`)\n    } else {\n      const result = {\n        ...args.options,\n        key: firstArgument.slice(1, -1),\n      }\n      if (isDefaultValueString) {\n        result.defaultValue = secondArgument.slice(1, -1)\n      }\n      this.keys.push(result)\n    }\n  }\n\n  createFunctionRegex() {\n    const functionPattern = this.functionPattern()\n    const curlyPattern = '(?:{{)' + functionPattern + '\\\\s+(.*?)(?:}})'\n    const parenthesisPattern = '(?:\\\\()' + functionPattern + '\\\\s+(.*)(?:\\\\))'\n    const pattern = curlyPattern + '|' + parenthesisPattern\n    this.functionRegex = new RegExp(pattern, 'gi')\n    return this.functionRegex\n  }\n\n  createArgumentsRegex() {\n    const pattern =\n      '(?:\\\\s+|^)' +\n      '(' +\n      '(?:' +\n      BaseLexer.variablePattern +\n      '(?:=' +\n      BaseLexer.stringOrVariablePattern +\n      ')?' +\n      ')' +\n      '|' +\n      BaseLexer.stringPattern +\n      ')'\n    this.argumentsRegex = new RegExp(pattern, 'gi')\n    return this.argumentsRegex\n  }\n}\n"],"mappings":"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"}